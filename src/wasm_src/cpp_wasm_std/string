#pragma once

#include <stdlib.h>

namespace std {
    // very partially implemented only for building the btHashMap
    class string {
    private:
        size_t m_length;
        char* m_str;
        
        static size_t strlen(const char* str) {
            const char* s;
            for (s = str; *s; ++s);
            return (s - str);
        }

        static void strcpy(char* dest, const char* src) {
            while (*src) {
                *dest = *src;
                dest += 1;
                src += 1;
            }
            *dest = '\0';
        }

    public:
        string() : m_length(0), m_str(nullptr) {}
        
        string(const char* str) :
            m_length(strlen(str)),
            m_str(static_cast<char*>(malloc(m_length + 1))) {
            strcpy(const_cast<char*>(m_str), str);
        }

        ~string() { // destructor
            free(static_cast<void*>(const_cast<char*>(m_str)));
        }

        string(const string& other) : // copy constructor
            m_length(other.m_length),
            m_str(static_cast<char*>(malloc(m_length + 1))) {
            strcpy(const_cast<char*>(m_str), other.m_str);
        }

        string(string&& other) { // move constructor
            char* tmp_str = m_str;
            m_str = other.m_str;
            other.m_str = tmp_str;

            size_t tmp_length = m_length;
            m_length = other.m_length;
            other.m_length = tmp_length;
        }

        string& operator=(const string& other) { // copy assignment
            if (this != &other) {
                free(static_cast<void*>(const_cast<char*>(m_str)));
                m_length = other.m_length;
                m_str = static_cast<char*>(malloc(m_length + 1));
                strcpy(const_cast<char*>(m_str), other.m_str);
            }
            return *this;
        }

        string& operator=(string&& other) { // move assignment
            if (this != &other) {
                char* tmp_str = m_str;
                m_str = other.m_str;
                other.m_str = tmp_str;

                size_t tmp_length = m_length;
                m_length = other.m_length;
                other.m_length = tmp_length;
            }
            return *this;
        }

        bool operator==(const string& other) const {
            if (m_length != other.m_length) {
                return false;
            }
            bool equal = true;
            for (size_t i = 0; i < m_length; i++) {
                if (m_str[i] != other.m_str[i]) {
                    equal = false;
                    break;
                }
            }
            return equal;
        }

        const char* c_str() const {
            return m_str;
        }
    };
}
